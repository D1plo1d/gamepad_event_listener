// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.GamePadEventListener = (function() {
    GamePadEventListener.prototype.gamepads = {};

    function GamePadEventListener(opts) {
      var _base;
      this.opts = opts;
      this.checkForGamePads = __bind(this.checkForGamePads, this);
      this._updateInterval = setInterval(this.checkForGamePads, opts.pollRate || 100);
      if ((_base = this.opts).deadzone == null) {
        _base.deadzone = 0.2;
      }
    }

    GamePadEventListener.prototype.checkForGamePads = function() {
      var currentGamepads, i, pad, previous, val, _base, _base1, _base2, _i, _j, _k, _l, _len, _len1, _m, _name, _ref, _ref1, _ref2, _ref3, _ref4;
      currentGamepads = [];
      _ref = navigator.webkitGetGamepads();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pad = _ref[_i];
        if (pad == null) {
          continue;
        }
        previous = this.gamepads[pad.index];
        pad = currentGamepads[pad.index] = {
          axes: pad.axes,
          buttons: pad.buttons,
          index: pad.index
        };
        for (i = _j = 0, _ref1 = pad.axes.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          if (Math.abs(pad.axes[i]) < this.opts.deadzone) {
            pad.axes[i] = 0;
          } else {
            pad.axes[i] = (pad.axes[i] - this.opts.deadzone) / (1 - this.opts.deadzone);
          }
        }
        if ((previous != null) === false) {
          this.opts.connect(pad);
        } else {
          for (i = _k = 0, _ref2 = pad.buttons.length - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
            if (previous.buttons[i] === pad.buttons[i]) {
              continue;
            }
            if (typeof (_base = this.opts)[_name = pad.buttons[i] === 1 ? "btnDown" : "btnUp"] === "function") {
              _base[_name](pad, i);
            }
          }
          for (i = _l = 0, _ref3 = pad.axes.length - 1; 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; i = 0 <= _ref3 ? ++_l : --_l) {
            val = pad.axes[i];
            if (val === previous.axes[i]) {
              continue;
            }
            if (typeof (_base1 = this.opts).axisChange === "function") {
              _base1.axisChange(pad, i, val);
            }
          }
        }
      }
      _ref4 = this.gamepads;
      for (_m = 0, _len1 = _ref4.length; _m < _len1; _m++) {
        pad = _ref4[_m];
        if (currentGamepads[pad.index] == null) {
          if (typeof (_base2 = this.opts).remove === "function") {
            _base2.remove(pad);
          }
        }
      }
      return this.gamepads = currentGamepads;
    };

    return GamePadEventListener;

  })();

}).call(this);
